Let's break down the complexity of each function and the overall code:

**`calculate_factorial(n)` function:**

* The function has a recursive structure, where it calls itself until it reaches the base case (`n == 0`).
* The time complexity of this function is O(n), because it makes n recursive calls.
* The space complexity is also O(n), because each recursive call adds a new layer to the call stack.

**`is_prime(num)` function:**

* The function has a simple iterative structure, where it checks divisibility of `num` with numbers from 2 to `num-1`.
* The time complexity of this function is O(n), because it iterates up to `num` times.
* The space complexity is O(1), because it only uses a fixed amount of space to store the loop variable and the result.

**Overall code:**

* The code calls `calculate_factorial(5)` and `is_prime(11)`, which have complexities O(5) and O(11), respectively.
* Since these complexities are constants, we can simplify them to O(1) each.
* The overall time complexity of the code is O(1) + O(1) = O(1), because the complexities are additive.
* The overall space complexity is also O(1), because the space usage is constant.

So, the overall complexity of this code is O(1) for time and O(1) for space.

Note that the `is_prime(num)` function has a poor time complexity for large values of `num`, because it checks divisibility up to `num`. A more efficient approach would be to check up to the square root of `num`, which would reduce the time complexity to O(âˆšn).